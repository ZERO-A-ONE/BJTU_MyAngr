# 80x86汇编笔记02

## 模式定义

### 指定使用的指令集

.386语句是汇编语句的伪指令，类似的指令还有：.8086、.186、.286、.386/386p、.486/486p和.586/586p等，用于告诉编译器在本程序中使用的指令集

在DOS的汇编中默认使用的是8086指令集，Win32环境工作在80386及以上的处理器中，所以需要指定指令集

另外，后面带p的伪指令则表示程序中可以在使用特权指令，这一类特权指令必须在特权级0上运行

### model语句

.model语句在低版本的宏汇编中已经存在，用来定义程序工作的模式，它的使用方法是

```
.model 内存模式 [语言模式][其他模式]
```

#### 内存模式

|  模式   |                        内存使用方式                        |
| :-----: | :--------------------------------------------------------: |
|  tiny   | 用来建立.com文件，所有的代码、数据和堆栈都在同一个64KB段内 |
|  small  |          建立代码和数据分别用一个64KB段的.exe文件          |
| medium  |         代码段可以有多个64KB段，数据段只有个64KB段         |
| compact |         代码段只有一个64KB，数据段可以有多个64KB段         |
|  large  |              代码段和数据段都可以有多个64KB段              |
|  huge   |       同large，并且数据段中的一个数组也可以超过64KB        |
|  flat   |      WIn32程序使用的模式，代码和数据段使用同一个4GB段      |

对于Win32程序来说，只有一种内存模式，即flat(平坦模式)，意思是内存是很平坦的从0延伸到4GB，再没有64KB段大小限制。因为4GB空间用32位的寄存器全部都能访问到，不必在头脑中随时记着当前使用的是哪个数据段。

如果定义了`.model flat`，MASM自动为各种段寄存器做了如下定义：

```assembly
ASSUME cs:FLAT,ds:FLAT,ss:FLAT,es:FLAT,fs:ERROR,gs:ERROR
```

也就是说，CS、DS、SS和ES段全部使用平坦模式。FS和GS寄存器默认不使用，但如果要使用需要声明：

```assembly
assume fs:nothing,gs:nothing ；或者
assume fs:FLAT,gs:FLAT
```

#### 语言模式

在Win32汇编中，model语句还指定语言模式，即子程序和调用方式。一般使用的是stdcall，它指出了调用子程序或Win32 API时参数传递的次序和堆栈平衡的方法

还有C，SysCall，BASIC，FORTAN和PASCALL

因为Windows的API调用使用的是stdcall格式，所以在Win32汇编中没有选择，必须在.model中加上stdcall参数

##### _stdcall调用

一般是Pascal程序的缺省调用方式。参数采用从右到左的压栈方式，被调函数自身在返回前清空堆栈

##### _cdecl调用

一般是C/C++程序的缺省调用方式。参数采用从右到左的压栈方式，传送参数的内存栈由调用者维护。cdecl约定的函数只能被C/C++调用，每一个调用它的函数都包含清空堆栈的代码，所以产生的可执行文件大小会比调用stdcall函数的大

### option语句

如`option casemap:none`的意义是告诉编译器程序中的变量名和子程序名是否对大小写敏感。由于Win32 API的API函数名称本质是区分大小写的，所以必须指定这个选项，否则调用API函数就会出现问题

## 段的定义

```assembly
.386
.model flat,stdcall
option casemap:none
<一些include语句>
.stack [堆栈段的大小]
.data
<一些初始化过的变量定义>
.data?
<一些没有初始化过的变量定义>
.const
<一些常量定义>
.code
	<代码>
	<开始标号>
		<其他语句>
end 开始标号
```

stack、data、data？、const和code都是分段伪指令，Win32中实际上只有代码和数据之分

data、data？和const这些都是指向数据段，code是指向代码段

和DOS汇编不同，Win32汇编不必考虑堆栈，系统会为程序分配一个向下的拓展的、足够大的段作为堆栈段，所以stack段定义常常被忽略

## Win32和DOS的不同

所以Win32中段，实际上并不是DOS汇编中那种意义的段，而是内存的“分段”。上一个段的结束就是下一个段的开始，所有的分段，合起来，包括系统使用的地址空间，就组成了整个可以寻址的4GB空间

Win32汇编的内存管理使用了80386处理器的分页机制，每个页(4KB大小)可以自由指定属性，所以上一个4KB可能是代码，属性是可执行但不可写，下一个4KB就有可能是既可读也可写但不可执行的数据

Win32汇编程序中“分段”的概念实际上是把不同类型的数据或代码归类，再放到不同属性的内存页（也就是不同的“分段”）中，这中间不涉及使用不同的段选择器

## 数据段

data、data？和const定义的是数据段，分别对应不同方式的数据定义，在最后生成的可执行文件中也分别放在不同的节区(Section)中

程序中的数据定义一段可以归纳为3类：

- 可读可写的已定义变量
  - 这些数据在源程序中已经被定义了初始值，而且在程序的执行中有可能被更改
  - .data段是已初始化数据段，其中定义的数据是可读可写的，在程序装入完成的时候，这些值就已经在内存中，data段存放在可执行文件的_DATA节区内
- 可读可写的未定义变量
  - 这些变量一般是当做缓冲区或者在程序执行后才开始使用的，这些数据可以定义在.data段中，也可以定义在.data?段中，但一般把它放到.data?段中
  - 虽然定义在这两种段中都可以正常使用，但定义在.data?段中不会增大.exe文件的大小
  - 举例说明，如果要用到一个100KB的缓冲区，可以在数据段中定义
    - `szBuffer	db	100*1024 dup(?)`
    - 如果放在.data段中，编译器认为这些数据在程序装入时必须有效，所以它在生成可执行文件的时候保留了所有的100KB内容
    - 如果放在.data?段中，其中的内容编译器会认为程序在开始执行后才会用到，所以它在生成可执行文件的时候只保留了大小信息，不会浪费磁盘空间
- 常量
  - 这些数据放在.const段中，它是可读不可写的
  - 一般为了方便起见，在小程序中常常把常量一起定义到data段中，而不另外定义一个const段
  - 如果想要写入const段中的数据，会引起保护错误

## 代码段

code段是代码段，所有的指令都必须写在代码段中，在可执行文件中，代码段是放在_TEXT节区中的。Win32环境中的数据段是不可执行的，只有代码段有可执行的属性。对于工作在特权级3的应用程序来说，code段是不可写的

在Windows95下，在特权级0下运行的程序对所有的段都有读写的权利，包括代码段。另外，在优先级3下与运行的程序也不是一定不能写代码段，代码段的属性是由可执行文件PE头部中的属性位决定的。通过编辑磁盘上的exe文件，把代码段属性位改成可写，那么在程序中就允许修改自己的代码段

> 一些典型的应用就是一些针对可执行文件的压缩软件和加壳软件，如UPX和PeCompact等
>
> 这些软件靠把代码段进行变换来达到解压缩和解密的目的，被处理过的可执行文件在执行时需要由解压代码来将代码段解压缩，这就需要写代码段，所以这些软件对可执行文件代码段的属性预先做修改

## 程序结束和程序入口

在汇编程序中，并没有一个main函数，程序员可以指定从代码段的任何一个地方开始执行，这个地方由程序最后一句的end语句来指定

```assembly
end [开始地址]
```

这句语句同时表示源程序结束，所有的代码必须在end语句之前。但是，一个源程序不必非要指定入口标号，这时候可以把开始地址忽略不写，这种情况发生在编写多模块程序的单个模块的时候

当分开写多个程序模块时，每个模块的源程序中也可以包括data、data？、const和code段，只是其他模块最后的end语句必须不带开始地址

当最后多个模块链接在一起的时候，只能由一个主模块指定入口地址，在多个模块中指定入口地址或者没有一个模块指定了入口地址，链接程序都会报错

## 换行

当源程序的某一行过长，不利于阅读的时候，可以分行书写，分行的办法是在一行的最后用反斜杠(\\)做换行符

## 调用API函数

> #### Win32程序是构筑在Win32 API基础上的。在Win32 API中，包括了大量的函数、结构和消息等，它不仅为应用程序所调用，也是Windows自身的一部分，Windows自身的运行也调用这些API函数

程序调用系统功能的一般过程：首先，系统提供功能模块并约定参数的定义方法，同时约定调用的方式，同时约定调用的方式，应用程序按照这个约定来调用系统功能

在DOS常用系统中断来实现调用。与DOS中断相比，Win32的系统功能模块放在Windows的动态链接库(DLL中)

> DLL是一种Windows的可执行文件，采用的是和我们熟悉的exe文件同样的PE约定格式，装着各种系统的API函数。实际上，Win32的基础就是由DLL组成的。Win32 API的核心由3个DLL提供，它们是：
>
> - KERNEL32.DLL：系统服务功能，包括内存管理、任务管理和动态链接等
> - GDI32.DLL：图形设备接口，处理图形绘制
> - USER32.DLL：用户接口服务，建立窗口和传送消息
>
> 还有其他的不同DLL，例如使用TCP/IP协议进行网络通信的DLL是Wsock32.dll，它所提供的API称为Socker API；专用于电话服务方面的API称为TAPI（Telephony API），包含在Tapi32.dll中

## API函数的参数

DOS下通过中断来调用系统“函数”，其中的“参数”是通过放在寄存器中

Win32 API是用堆栈来传递参数的，调用者把参数一个个压入堆栈，DLL中的函数程序再从堆栈中取出参数处理，并在返回之前将堆栈中已经无用的参数丢弃。在《Microsoft Win32 Programmer's Reference》中定义了常用API的参数和函数声明

Win32环境中的参数实际上只有一种类型，那就是一个32位的整数，实际上就是汇编中的dword（double word、dd、双字型、4个字节、两个字、32位）

Windows所有编程资料发布的格式也是C格式

例子，在汇编中调用MessageBox函数的方法是：

```assembly
push uType
push lpCaption
push lpText
push hWnd
call MessageBox
```

在源程序编译链接成可执行文件后，call MessageBox语句中的MessageBox会被换成一个地址，指向可执行文件中的导入表的一个索引（函数名或索引号）

导入表中指向MessageBox函数的实际地址会在程序装入内存的时候，根据User32.dll在内存中的位置由系统动态填入

## 使用invoke语句

API是可以调用了，另一个麻烦的问题是Win32的API动辄就是十几个参数，整个源程序一眼看上去基本上都是把参数压堆栈的push指令，参数的个数和顺序很容易搞错，源程序可读性差

微软在MASM中提供了一个伪指令实现了一句中打入所有的参数，并在参数使用错误的时候能够提示，那就是invoke伪指令

```assembly
invoke 函数名 [参数1][参数2]...[参数n]
```

例如调用MessageBox函数：

```assembly
invoke MessageBox,NULL,offsetszText,offset szCaption,MB_OK
```

> invoke并不是80386处理器的指令，而是一个MASM编译器的伪指令，在编译的时候它把上面的指令展开成我们需要的4个push指令和一个call指令，同时进行参数数量的检查工作

对于不带参数的API调用，invoke伪指令的参数检查功能可有可无，既可以用call也可以用invoke

## API函数的返回值

返回值的类型对于汇编程序来说也只有dword一种类型，它永远放在eax中

如果要返回的内容不是一个eax所能容纳的，Win32 API采用的方式一般是返回一个指针，或者在调用参数中提供一个缓冲区地址，干脆把数据直接返回到缓冲区中去

## 函数的声明

在调用API函数的时候，函数原型也必须预先声明，声明函数的格式是：

```
函数名	proto	[距离][语言][参数1]:数据类型,[参数2]:数据类型
```

`proto`是函数声明的伪指令，距离可以是NEAR、FAR、NEAR16、NEAR32、FAR16或FAR32，Win32中只有一个平坦的段，无所谓距离，所以在定义的时候忽略的

对于Win32汇编来说只存在dword类型的参数，所以所有的参数类型永远都是dword，另外对于参数的名称其实是无用的，仅为了可读性，所以下面两句消息框函数的定义是一致的：

```assembly
MessageBox Proto hWnd:dword,lpText:dword,lpCation:dword,uType:dword
```

```assembly
MessageBox	Proto :dword,:dword,:dword,:doword
```

在Win32环境中，和字符串相关的API共有两类，分别对应两个字符集：一类是处理ANSI字符集(1B)的，另一类是处理Unicode字符集(2B)的。前一类函数名字的尾部带一个A字符，另一种则带一个W字符

## include语句

在MASM32工具包中已经包括了所有DLL的API函数声明列表，每个DLL对应.inc文件，在源程序中只要使用include包含进来就可以了，例如：

```
include user32.inc
include kernel32,inc
```

## includelib语句

一个DLL文件对应一个导入库，如User32.dll文件用于编程的导入库是User32.lib，MASM32工具包中包含了所有DLL的导入库

和inlcude语句的处理不同，includelib不会吧.lib文件插入到源程序中，它只是告诉连接器在链接的时候到指定的库文件中去找而已。DLL文件中的函数没有包括声明，所以才需要将.inc文件插进去