# 8086汇编笔记05

## 中断

中断是CPU处理外部突发事件的一个重要技术，它能使CPU在运行过程中对外部事件发出的中断请求及时地进行处理，处理完成后又立即返回断点，继续进行CPU原来的工作。引起中断的原因或者说发出中断请求的来源叫做中断源。根据中断源的不同，可以把中断分为**硬件中断**和**软件中断**两大类，而硬件中断又可以分为**外部中断**和**内部中断**两类

CPU为了处理并发的中断请求，规定了中断的优先权，中断优先权由高到低的顺序是：

1. 除法错、溢出中断、软件中断
2. 不可屏蔽中断
3. 可屏蔽中断
4. 单步中断

## 外部中断

外部中断一般是指由计算机外设发出的中断请求，如：键盘中断、打印机中断、定时器中断等。外部中断使可以屏蔽的中断，也就是说，利用中断控制器可以屏蔽这些外部设备的中断请求

## 内部中断

内部中断是指因硬件出错（突然掉电、奇偶校验错等）或运算出错（除数为零、运算溢出、单步中断等）所引起的中断。内部中断是不可屏蔽的中断

## 软件中断

软件中断其实并不是真正的中断，它们只是可被调用执行的一般程序以及DOS的系统功能调用（INT 21H）等都是软件中断

## 中断处理程序

CPU的设计者必须在中断信息和其处理程序的入口地址之间建立某种联系，使得CPU根据中断信息可以找到要执行的处理程序。中断信息中包含有标识中断源的类型码，根据CPU的设计，中断类型码的作用就是用来定位中断处理程序，比如CPU根据中断程序码4，就可以找到4号中断的处理程序

若要定位中断处理程序，需要知道它的段地址和偏移地址，如果需要根据8位的中断类型码（8086中断类型码为一个字节）得到中断处理程序的段地址和偏移地址，需要引入“中断向量表”

## 中断向量表

CPU用8位的中断类型码通过中断向量表找到相应的中断处理程序的入口地址，中断向量表就是中断向量的列表

|   0号中断元对应的中断处理程序的入口地址   |
| :---------------------------------------: |
| **1号中断元对应的中断处理程序的入口地址** |
| **2号中断元对应的中断处理程序的入口地址** |
|                  **……**                   |

中断向量表在内存中保存，其中存放着256个中断源所对应的中断处理程序的入口。**对于8086PC机，中断向量表指定放在内存地址0处，从内存0000:0000到0000:03FF的1024个单元**

## 中断过程

CPU硬件完成中断工作的过程被称为中断过程：

- 利用中断类型码，在中断向量表中找到中断处理程序的入口
- 找到这个入口地址的最终目的是用它设置CS和IP，使CPU执行中断处理程序
- 用中断类型码找到中断向量，并用它设置CS和IP，这个工作是由CPU的硬件自动完成的

8086CPU的中断过程：

- 从中断信息中取得中断类型码
- 标志寄存器的值入栈（保护标志位）
- 设置标志寄存器的第8位TF和第9位IF的值为0
- CS的内容入栈
- IP的内容入栈
- 从内存地址为中断类型码\*4和中断类型码\*4+2的两个字单元中读取中断处理程序的入口地址设置IP和CS

```
1.取得中断类型码N；
2.pushf
3.TF=0，IF=0
4.push CS
5.push IP
6.(IP)=(N*4)，(CS)=(N*4+2)
```

## 中断处理程序

由于CPU随时都可能检测到中断信息，也就是说，CPU随时都可能执行中断处理程序，所以中断处理程序必须一直存储在内存某段空间之中，而中断处理程序的入口地址，即中断向量，必须存储在对应的中断向量表表项中

中断处理程序的编写方法和子程序的比较相似，下面是常规的步骤：

- 保存用到的寄存器
- 处理中断
- 恢复用到的寄存器
- 用iret指令返回
  - iret指令的功能用汇编语法描述为：
    - pop IP
    - pop CS
    - popf
  - iret通常和硬件自动完成的中断过程配合使用

可以看到，在中断过程中，寄存器入栈的顺序是标志寄存器、CS、IP，而iret的出栈顺序是IP、CS、标志寄存器，刚好和其对应，实现了用执行中断处理程序前的CPU现场恢复标志寄存器和CS、IP的工作

## 除法错误中断的处理

当CPU执行div等除法指令的时候，如果发生了除法溢出错误，将产生中断类型码为0的中断信息，CPU将检测到这个信息，然后引发中断过程，转去执行0号中断所对应的中断处理程序

## 编程处理0号中断

- 当发生除法溢出的时候，产生0号中断信息，从而引发中断过程，此时CPU经行以下工作
  - 取得中断类型码0
  - 标志寄存器入栈，TF、IF设置为0
  - CS、IP入栈
  - (IP)=(0*4)，(CS)=(0\*4+2)
- 可见当中断0发生时，CPU将去执行处理程序，要显示特定字符串只需这样写：
  - 相关处理
  - 向显示缓冲区送字符串"Welcome to"
  - 返回DOS
- 必须将do 0 的入口地址等级在中断向量表的对应表项中，因为除法溢出对应的中断类型码为0则：
  - 入口地址应该从0x4地址单元开始存放
  - 段地址存放在0x4+2字单元中
  - 偏移地址存放在0x4字单元中
- 总结上面的分析：
  - 编写可以显示字符串的中断处理程序：do 0
  - 将do 0送入内存0000:0200处
  - 将do 0的入口地址0000:0200存储在中断向量表0号表项中

普通的示例：

```assembly
assume cs:code
data segment
        db "Hello World!"
data ends
code segment
start:
        mov ax,cs 
        mov ds,ax
        mov si,offser dp0   ;设置ds:si指向源地址
        mov ax,0
        mov es,ax
        mov di,200h         ;设置es:di指向目的地址
        mov cx,offset do0end- offset do0    ;设置cx为传输长度
        cld                 ;设置传输方向为正
        rep movsb

        mov ax,0;设置中断向量表
        mov es,ax
        mov word ptr es:[0*4],200h
        mov word ptr es:[0*4+2],0

        mov ax,4c00h
        int 21h
do0:    ;显示字符串
        mov ax,data 
        mov ds,ax
        mov si,0            ;设置ds:si指向字符串
        mov ax,0b800h
        mov es,ax
        mov di,12*160+36*2  ;设置es:di指向显存空间的中间位置
        mov cx,21           ;设置cx为字符串长度
doend:
        nop
code ends
end start
;"-"是编译器可以识别的运算符号，两个常数的减法，编译器还可以处理很多表达式
```

但是这样有一个问题，字符串存放在程序的data段中。程序执行完成后返回，它所占用的内存空间被系统释放，而在其中存放的字符串也将很可能被别的信息覆盖，很难保证do0程序从原来程序program1所处的空间中取得的是要显示的字符串。所以该字符串也应该存放在一段不会被覆盖的空间中

所以，改进后将数据存放到代码段中：

```assembly
assume cs:code
code segment
start:
        mov ax,cs 
        mov ds,ax
        mov si,offser dp0   ;设置ds:si指向源地址
        mov ax,0
        mov es,ax
        mov di,200h         ;设置es:di指向目的地址
        mov cx,offset do0end- offset do0    ;设置cx为传输长度
        cld                 ;设置传输方向为正
        rep movsb

        mov ax,0;设置中断向量表
        mov es,ax
        mov word ptr es:[0*4],200h
        mov word ptr es:[0*4+2],0
        
        mov ax,4c00h
        int 21h
do0:    
        jmp short do0start
        db  "Hello World"   ;将数据存放在代码段
do0start:
        mov ax,cs
        mov ds,ax
        mov si,202h         ;设置ds:si指向字符串
        mov ax,0b800h
        mov es,ax
        mov di,12*160+36*2  ;设置es:di指向显存空间的中间位置
        mov cx,21           ;设置cx为字符串长度
doend:
        nop
code ends
end start
```

## 单步中断

只有CPU提供了在执行一条指令后就转去做其他事情的能力，Debug或是其他的程序才能利用CPU提供的这种功能做出我们使用T命令时的效果

CPU在执行完一条指令之后，如果检测到标志寄存器的TF位为1，则产生单步中断，引发终端过程

单步中断的中断类型码为1，则它所引发的中断过程如下：

- 取得中断类型码1
- 标志寄存器入栈，TF、IF设置为0
- CS、IP入栈
- (IP)=(1*4),(CS)=(1\*4+2)

所以如果TF=1，则执行一条指令后，CPU就要转去执行1号中断处理程序

在使用T命令执行指令时，Debug将TF设置为1，使得CPU在工作于单步中断方式下，则在CPU执行完这条指令后就引发单步中断，执行单步中断的中断处理程序，所有寄存器中的内容被显示在屏幕上，并且等待输入命令

## 响应中断的特殊情况

在有些情况下，CPU在执行完当前指令后，即便是发生中断，也不会响应

#### 在执行完向ss寄存器传送数据的指令后

这样做的主要原因是ss:sp联合指向栈，而对它们的设置应该连续完成，因为如果在执行完设置ss的指令后，没设置sp寄存器，CPU响应中断的话，压栈标志寄存器、CS和IP的值，ss:sp指向的不是正确的栈顶，将引起错误

我们应该利用这个特性，将设置ss和sp的指令连续存放，之间CPU不会引发中断过程

